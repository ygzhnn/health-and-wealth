# -*- coding: utf-8 -*-
"""outdoor_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-tg38nX5BJt3lQFsF1NhRISneLDS9toj
"""

!pip install -q google-generativeai pillow pandas matplotlib

import pathlib
import google.generativeai as genai
import PIL.Image
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import io
import json
import base64
from google.colab import files
import IPython.display as display

GOOGLE_API_KEY = "API_ANAHTARINIZI_BURAYA_YAZIN"
genai.configure(api_key=GOOGLE_API_KEY)

def load_image_from_upload():
    """Kullanıcıdan görüntü yükler."""
    print("Lütfen analiz edilecek şehir/çevre fotoğrafını yükleyin:")
    uploaded = files.upload()

    if not uploaded:
        return None

    image_path = list(uploaded.keys())[0]
    return PIL.Image.open(image_path)

def display_image(image):
    """Görüntüyü göster."""
    plt.figure(figsize=(10, 10))
    plt.imshow(image)
    plt.axis('off')
    plt.show()

def analyze_environment_with_gemini(image):
    """Analyze the image using Gemini API."""
    if image is None:
        print("Failed to load image!")
        return None

    # Display the image
    display_image(image)

    # Select Gemini's vision model
    model = genai.GenerativeModel('gemini-1.5-flash')

    # Prepare the analysis prompt
    prompt = """
    Analyze this urban/environmental image and evaluate the following factors on a 0-100 scale:

    1. Green Space: Trees, plants, parks, natural areas, etc.
    2. Traffic: Vehicles, roads, traffic density, etc.
    3. Crowd: Human density, crowdedness, etc.
    4. Water Features: Sea, lake, river, pool, etc.
    5. Urbanization: Buildings, structures, urban areas, etc.

    Provide output in the following JSON format:
    {
        "green_space": 0-100 score,
        "traffic": 0-100 score,
        "crowd": 0-100 score,
        "water_features": 0-100 score,
        "urbanization": 0-100 score,
        "detected_features": ["feature1", "feature2", ...],
        "overall_assessment": "Brief evaluation of this area's environmental characteristics"
    }

    Return only the JSON output, without any additional commentary.
    """

    try:
        # API call
        response = model.generate_content([prompt, image])

        # Extract JSON from response
        json_start = response.text.find('{')
        json_end = response.text.rfind('}') + 1
        json_str = response.text[json_start:json_end]

        return json_str
    except Exception as e:
        print(f"Error analyzing image: {str(e)}")
        return None

def parse_gemini_response(response_text):
    """Gemini API'nin JSON yanıtını parse et."""
    try:
        # JSON bölümünü ayıkla (yanıt bazen ek metin içerebilir)
        json_str = response_text

        # Eğer yanıt ```json ve ``` arasında ise
        if "```json" in response_text:
            json_str = response_text.split("```json")[1].split("```")[0].strip()
        # Eğer sadece ``` kullanılmışsa
        elif "```" in response_text:
            json_str = response_text.split("```")[1].strip()

        # JSON'ı parse et
        result = json.loads(json_str)
        return result
    except Exception as e:
        print(f"JSON parse hatası: {e}")
        print(f"Ham yanıt: {response_text}")
        return None

def visualize_environmental_scores(scores):
    """Çevresel skorları pasta grafiği olarak görselleştir."""
    # Sadece skorları al, açıklamaları vb. dışarıda bırak
    env_scores = {k: v for k, v in scores.items()
                 if isinstance(v, (int, float)) and k not in ["tespit_edilen_özellikler", "genel_değerlendirme"]}

    # Pasta grafiği oluştur
    plt.figure(figsize=(10, 6))
    labels = env_scores.keys()
    sizes = env_scores.values()

    # Renk paleti
    colors = ['#8fd16f', '#ff6b6b', '#4e79a7', '#76b7b2', '#edc948']

    plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%',
            shadow=False, startangle=90)
    plt.axis('equal')
    plt.title('Çevresel Faktör Analizi')
    plt.show()

    # Radar grafiği de ekle
    plt.figure(figsize=(8, 8))
    categories = list(env_scores.keys())
    values = list(env_scores.values())

    # Radar grafiği için değerleri 0-1 arasına normalize et
    values_normalized = [v/100 for v in values]

    # Grafiği çiz
    angles = np.linspace(0, 2*np.pi, len(categories), endpoint=False).tolist()
    values_normalized += values_normalized[:1]  # Listeyi kapatmak için ilk değeri sona ekle
    angles += angles[:1]  # Listeyi kapatmak için ilk açıyı sona ekle
    categories += categories[:1]  # Etiketleri kapatmak için

    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))
    ax.plot(angles, values_normalized, 'o-', linewidth=2)
    ax.fill(angles, values_normalized, alpha=0.25)
    ax.set_thetagrids(np.degrees(angles[:-1]), categories[:-1])
    ax.set_ylim(0, 1)
    ax.grid(True)
    ax.set_title("Çevresel Faktörler Radar Grafiği", size=15)
    plt.show()

def calculate_stress_factor(env_scores):
    """Calculate potential stress factor based on environmental scores."""
    if not env_scores:
        return None

    # Define stress factors with English keys matching your JSON
    stress_factors = {
        'green_space': -0.7,  # Negative because green space reduces stress
        'traffic': 0.9,       # Positive because traffic increases stress
        'crowd': 0.8,         # Positive because crowds increase stress
        'water_features': -0.5, # Negative because water reduces stress
        'urbanization': 0.6    # Positive because urbanization increases stress
    }

    # Calculate base stress score (0-100)
    stress_score = 50  # Neutral starting point

    # Apply each factor
    for key, factor in stress_factors.items():
        if key in env_scores:
            # Normalize the score (0-100 to -1 to 1 range) before applying factor
            normalized_score = (env_scores[key] - 50) / 50
            stress_score += normalized_score * factor * 25

    # Ensure score stays within bounds
    stress_score = max(0, min(100, round(stress_score, 1)))

    return stress_score

def visualize_stress_level(stress_score):
    """Stres seviyesini gösterge olarak görselleştir."""
    if stress_score is None:
        return

    # Stres seviyesi göstergesi (gauge chart)
    fig, ax = plt.subplots(figsize=(8, 4))

    # Gösterge aralıkları
    categories = ['Düşük Stres', 'Orta Stres', 'Yüksek Stres']
    bounds = [0, 33, 66, 100]
    colors = ['#90EE90', '#FFFFE0', '#FFB6C1']

    # Gösterge aralıklarını çiz
    for i, (color, left, right) in enumerate(zip(colors, bounds[:-1], bounds[1:])):
        ax.barh(0, right-left, left=left, height=0.5, color=color)

    # İşaretçi ekle
    ax.barh(0, 0.5, left=stress_score, height=0.5, color='black')

    # Düzen ayarları
    ax.set_yticks([])
    ax.set_xlim(0, 100)
    ax.set_xticks(bounds)
    ax.set_xticklabels(['0', '33', '66', '100'])
    ax.set_title(f'Potansiyel Çevresel Stres Seviyesi: {stress_score:.1f}/100', size=14)

    # Kategori etiketlerini ekle
    for i, category in enumerate(categories):
        ax.text((bounds[i] + bounds[i+1]) / 2, -0.2, category,
                horizontalalignment='center', size=12)

    plt.tight_layout()
    plt.show()

# 11. Ana Fonksiyon
def main():
    """Ana çalıştırma fonksiyonu."""
    print("Urban Aura - Gemini API ile Çevresel Analiz")
    print("=" * 50)

    # 1. Görüntü yükle
    image = load_image_from_upload()
    if image is None:
        return

    # 2. Gemini API ile analiz et
    print("Gemini API ile görüntü analiz ediliyor...")
    response_text = analyze_environment_with_gemini(image)

    # 3. Yanıtı parse et
    env_results = parse_gemini_response(response_text)

    if env_results:
        # 4. Sonuçları göster
        print("\nÇevresel Analiz Sonuçları:")
        print("-" * 30)

        # Tespit edilen özellikleri yazdır
        if "tespit_edilen_özellikler" in env_results:
            print("Tespit Edilen Özellikler:")
            for feature in env_results["tespit_edilen_özellikler"]:
                print(f"- {feature}")
            print()

        # Skorları yazdır
        env_scores = {k: v for k, v in env_results.items()
                     if isinstance(v, (int, float)) and k not in ["tespit_edilen_özellikler", "genel_değerlendirme"]}

        for category, score in env_scores.items():
            print(f"{category.capitalize()}: {score}/100")

        # Genel değerlendirmeyi yazdır
        if "genel_değerlendirme" in env_results:
            print("\nGenel Değerlendirme:")
            print(env_results["genel_değerlendirme"])

        # 5. Skorları görselleştir
        visualize_environmental_scores(env_results)

        # 6. Stres faktörünü hesapla ve görselleştir
        stress_score = calculate_stress_factor(env_scores)
        if stress_score:
            print(f"\nPotansiyel Çevresel Stres Seviyesi: {stress_score:.1f}/100")
            visualize_stress_level(stress_score)

        # 7. Sonuçları sakla
        print("\nSonuçlar JSON formatında kaydediliyor...")
        with open("urban_aura_analysis.json", "w", encoding="utf-8") as f:
            json.dump(env_results, f, ensure_ascii=False, indent=2)

        print("Analiz tamamlandı! Sonuçlar 'urban_aura_analysis.json' dosyasına kaydedildi.")

        # 8. Sonuçları indirme bağlantısı oluştur
        with open("urban_aura_analysis.json", "r", encoding="utf-8") as f:
            content = f.read()

        download_link = f"""
        <a href="data:application/json;charset=utf-8,{content}"
           download="urban_aura_analysis.json">
           Sonuçları İndir
        </a>
        """
        display.display(display.HTML(download_link))
    else:
        print("Gemini API yanıtı işlenemedi.")

# API Anahtarını Kullanıcıdan Al
def set_api_key():
    """Gemini API anahtarını kullanıcıdan al."""
    print("Gemini API anahtarınızı girin:")
    api_key = input()
    genai.configure(api_key=api_key)
    print("API anahtarı ayarlandı!")

if __name__ == "__main__":
    if GOOGLE_API_KEY == "API_ANAHTARINIZI_BURAYA_YAZIN":
        set_api_key()
    main()

